---
title: exp/eval - TumpCpp リファレンス
---

```cpp
namespace tump {
    template <class... Terms>
    using exp = ...;

    template <class... Terms>
    using eval = typename exp<Terms...>::type;
}
```

## 概要

型テンプレートパラメータパック`Terms`を式として評価します。  

`exp`はメンバ型`type`から式の評価結果を取得する必要がありますが、パラメータパック`Terms`の情報は失われません。  
一方で、`eval`は式の評価結果を直接返却するため、パラメータパック`Terms`の情報にはアクセスできません。

## Termsに指定された型の分類

型テンプレートパラメータパック`Terms`には、任意の型を指定できますが、指定された型は以下の 3 種類に分類されます。

1. 第一級関数化されたメタ関数([{`tump::Invocable`|ref/invocable/invocable}]の適用結果、真と評価される型)
1. 演算子
1. メタ関数と演算子のどちらでもない型

## 第一級関数化されたメタ関数の評価

`Terms`において、第一級関数化されたメタ関数は、本来受け取る必要のある引数の数にかかわらず、1 引数を受け取る関数として処理されます。

もし、メタ関数の評価に必要な引数の数が足りない場合は、新たなメタ関数(第一級関数化された状態)が返却されます。  
新たなメタ関数は、引数の部分適用によって必要な引数が減った状態となります。  
※いわゆる、カリー化された関数として処理されます。

関数適用は、左側から、演算子を除いた右隣の型に対して行われます。  
ただし、右隣が演算子だった場合、関数の評価は演算子の評価が完了するまで中断します。  
上記のような演算子の性質を用いて、式の評価順序を制御することも可能で、詳細は[Termsの評価の優先度](#Termsの評価の優先度)にて後述します。

```cpp
// func1, func2, func3 は第一級関数化されたメタ関数、
// type1, type2 はメタ関数でも演算子でもない型とする
tump::eval<func1, func2, type1, tump::_apply, func3, type2>;
```

例えば、上記の式は下記の順序で評価が行われます。  

1. `func1`を`func2`に適用
2. 1 の結果のメタ関数を`type1`へ適用
3. `func3`を`type2`へ適用
4. 2 の結果のメタ関数を 3 の結果型に適用

なお、パラメータに制約があるメタ関数が評価される際、制約に抵触するような関数適用が行われているとエラーが発生します。

## 演算子の評価

演算子は左右のオペランドに対して既定の処理を行い、 2 引数を受け取るメタ関数と同様に評価されます。  
評価時の動作としては、2 引数のメタ関数と比較して、メタ関数は前置、演算子は中置であることのみが異なります。  
しかし、評価順序については関数適用よりも優先順位が低く、実施可能な関数適用がすべて完了したのちに演算子の評価が行われます。

また、各演算子についても優先度と結合性が設定されており、評価される順序が異なります。  

- 優先度 : 0 ~ 9 の値が設定されており、9 の演算子が最優先。
- 結合性 : 左結合、右結合、非結合のいずれかが設定されている。

なお、演算子は、中置のため、式の先頭または末尾に記述すると適用可能なオペランドが 1 つ足りない状態となり、文法エラーです。

```cpp
// 左オペランドが存在しないため NG
tump::eval<tump::_apply, type1>;

// 右オペランドが存在しないため NG
tump::eval<func1, tump::_apply>;
```

より詳しい内容については、[{演算子の項|ref/operator}]を参照ください。

## メタ関数と演算子のどちらでもない型の評価

メタ関数と演算子のどちらでもない型は、メタ関数の引数または、演算子のオペランドとして適用されます。  
そのため、該当の型に対して適用を行う関数や演算子が存在しない場合文法エラーです。

ただし、`Terms`に指定された型が 1 つだけの場合、関数適用などが発生する余地がなく、エラーとはなりません。  
受け取った型をそのまま返す動きとなります。

```cpp
// type1 に対して適用可能なメタ関数や演算子が存在しないため NG
tump::eval<type1, type2>;
tump::eval<type1, func1>;
tump::eval<type1, type2, tump::_eq, type3>;

// パラメータが 1 つだけの場合は OK
// 下記の式の結果として type1 が返却される
tump::eval<type1>;
```

## Termsの評価の優先度

パラメータパック`Terms`の評価順序については下記の順序で決定します。

1. ネストした`tump::exp`または`tump::eval`が存在する場合、その内容を評価する
2. `Terms`の左側のメタ関数ほど先に評価が行われる
3. メタ関数の適用が完了したのち、優先度の数字が大きい演算子の適用の評価が行われる
4. 左結合の演算子は`Terms`の先頭側から、右結合の演算子は`Terms`の最後尾側から先に評価され、非結合は位置による評価の優先度に意味はない

上記の通り、メタ関数の評価が演算子よりも優先的に行われます。  
一方で、メタ関数の右隣に演算子が出現した場合は、演算子の評価が終わるまで関数の適用が中断され、演算子の右隣の評価が開始されます。  
上記の性質を用いて、式の評価順序を操作することができます。

下記の例では、メタ関数の適用を行う演算子[{`tump::_apply`|ref/operator/apply}]を用いて、`func2`を`type1`に適用したのち、その結果に対して`func1`を適用しています。  
演算子を使わない場合、先に`func1`を`func2`に適用してしまうため、想定外の評価順序とならないように注意が必要です。

```cpp
// func2 を type1 へ適用したのち、その結果へ func1 を適用する
tump::eval<func1, tump::_apply, func2, type1>;

// func1 を func2 へ適用したのち、その結果を type1 へ適用する
tump::eval<func1, func2, type1>;
```

## 式のネスト

`tump::exp`または`tump::eval`は評価結果として、演算子を除いた型(第一級関数化されたメタ関数を含む)を返却します。  
そのため、パラメータパック`Terms`の中に、`tump::exp`または`tump::eval`を含めても問題ありません。  
※ネストした`tump::exp`または`tump::eval`の評価結果の型が、文法的に問題のない場所の場合のみ

上記の性質を用いて、ネストした`tump::exp`または`tump::eval`を用いることで、C++ の式における`()`と同様に、評価順序を制御することができます。  
ネストした`tump::exp`または`tump::eval`の内容が最も優先的に評価されます。

下記の例では、ネストした`tump::exp`または`tump::eval`を用いて、`func2`を`type1`に適用したのち、その結果に対して`func1`を適用しています。  
ネストした式として、`tump::exp`と`tump::eval`どちらを利用しても、まったく同じ動作となります。

```cpp
// func2 を type1 へ適用したのち、その結果へ func1 を適用する
tump::eval<func1, tump::exp<func2, type1>>;
// ネストした式は exp でも eval でも動作は同じ
tump::eval<func1, tump::eval<func2, type1>>;

// func1 を func2 へ適用したのち、その結果を type1 へ適用する
tump::eval<func1, func2, type1>;
```

## よくあるエラー

`tump::exp`または`tump::eval`を使用する際、下記のような内容のコンパイルエラーが発生し、不具合の原因を特定するのが骨です。

- テンプレートクラスの実体化に失敗
- 指定されたテンプレートパラメータに該当するテンプレートクラスの部分特殊化が存在しない
- テンプレートパラメータの数が多すぎる/少なすぎる

実際の原因は、概ね下記のいずれかと考えられますので、エラーが発生した周辺の式や、式の中で利用しているメタ関数の定義を確認してください。

- 文法ミス
- メタ関数に渡した引数の型が、制約に抵触している
- メタ関数の引数の数が合わない

## 関連リンク

- [{`tump::_apply`|ref/operator/apply}]
- [{`tump::_eq`|ref/operator/compare}]
